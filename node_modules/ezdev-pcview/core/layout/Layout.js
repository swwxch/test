/**
 * Created by zhaofs on 2016/7/19.
 * --------------------
 * - 布局 -
 * --------------------
 * 主要实现整体布局的控制，初始化等，如菜单，通知，退出等功能。
 */
import Events from "../base/Events";
import config from "../Config";
import ajaxRequest from "../ajax/AjaxRequest";

let resolveHandlerPath = function () {
    let hash = location.hash.slice(1);
    hash = hash.split('?')[0];
    return hash.substring(0, hash.lastIndexOf('/'));
};

export default class extends Events {
    constructor(menuUrl, menuId) {
        super();
        this.menus = {};
        this._menuUrl = menuUrl || config.menuUrl;
        this._menuId = menuId || config.menuId;
    }

    initLayout() {
        $(document).ready(function () {
            this.initMenu().then(function () {
                this.initDefaultUrl();
                this.activateMenu();
                this.fireEvent('initLayout', this);
            }.bind(this));
        }.bind(this));
    }

    /**
     * 初始化菜单
     */
    initMenu() {
        this.menuContainer = $(`#${this.menuId}`);
        return new Promise((resolve) => {
            let htmlStr = store.get('menuStr');
            if (htmlStr) {
                this.renderMenu(htmlStr);
                resolve({});
            } else {
                ajaxRequest.ajax({
                    type: "get",
                    url: this.menuUrl
                }).then(function (data) {
                    htmlStr = this.getMenuTpl()(data || {});
                    store.set('menuStr', htmlStr);
                    this.renderMenu(htmlStr);
                    resolve({});
                }.bind(this));
            }
        });
    }
    /**
     * 将menu数据转为父子关系的菜单数据
     * 根据data[menu]中相邻元素的level计算出父子关系
     * author:wangchen 2017/7/14
     */
    formatMenueData(data){
        let menu = data['menu'];
        let mm = [];
        let lastMenu = null;
        let parent = null;
        for(let i=0;i<menu.length;i++){
            menu[i]['children'] = [];
            menu[i]['parent'] = {};
            // console.log('name::'+menu[i]['name']+' level::'+menu[i]['level']);
            if(i==0){
                lastMenu = menu[i];
                parent  = menu[i];
            }
            if (menu[i]['level'] == 0) {
                mm.push(menu[i]);
            }else{
                // console.log('lastMenu[level]=='+lastMenu['level']);
                if(menu[i]['level'] > lastMenu['level']){
                    lastMenu['children'].push(menu[i]);
                    menu[i]['parent'] = lastMenu;
                    parent = lastMenu;
                    parent['hasChildren'] = true;
                }else if(menu[i]['level'] == lastMenu['level']){
                    let tp = lastMenu['parent'];
                    tp['children'].push(menu[i]);
                    menu[i]['parent'] = tp;
                    parent = tp;
                }else{
                    let tp = lastMenu['parent'];
                    while(tp.level >= menu[i]['level']){
                        tp = tp['parent'];
                    }
                    // console.log('tp.name::'+tp['name']+' tp.level::'+tp['level']);
                    tp['children'].push(menu[i]);
                    menu[i]['parent'] = tp;
                    tp['hasChildren'] = true;
                }
            }

            lastMenu = menu[i];
        }

        data['mm'] = mm;

        return data;
    }

    /**
     * 生成tree的某个node及其子node的html字符串
     * author:wangchen 2017/7/17
     * parameter:node 节点数据信息
     * parameter:defaultActive 是否默认为active
     * @returns node(html)
     */
    generateTreeNode(node,defaultActive){
        let htmlArr = [];//节点全部html，li逻辑代价
        let aTagArr = [];//点击链接
        let ulTagArr = [];//子节点
        let ifLiClass = false;
        htmlArr.push('<li ');
        aTagArr.push('<a');
        if(node.hasChildren == true){
            htmlArr.push('class="treeview ');
            ifLiClass = true;
            aTagArr.push(' href="#">');
            aTagArr.push('<i class="glyphicon glyphicon-');
            aTagArr.push(node.icon);
            aTagArr.push('"></i> <span>');
            aTagArr.push(node.name);
            aTagArr.push('</span>');
            aTagArr.push('<i class="fa fa-angle-left pull-right"></i>');
            aTagArr.push('</a>');
            ulTagArr.push('<ul class="treeview-menu">');
            let children = node.children;
            if(children&& children.length>0){
                for (let i = 0; i<children.length; i++) {
                    ulTagArr.push(this.generateTreeNode(children[i],false));
                }
            }
            ulTagArr.push('</ul>');
        }else{
            let hrefUrl = null;
            if (node.url.indexOf('MAX') > -1) {
                node.url = node.url.replace('MAX', '');
            }
            if (node.target == 0 ) {
                hrefUrl = node.url;
            }else if(node.target == 1 ){
                hrefUrl = node.code+'target=iframe&src='+node.url;

            }else if(node.target == 2 ){
                hrefUrl = node.code+'target=window&src='+node.url;
            }
            aTagArr.push(' href="#');
            aTagArr.push(hrefUrl);
            aTagArr.push('"><i class="glyphicon glyphicon-');
            aTagArr.push(node.icon);
            aTagArr.push('"></i><span>');
            aTagArr.push(node.name);
            aTagArr.push('</span></a>');

        }
        if(defaultActive){
            if(ifLiClass){
                htmlArr.push('active');
            }else{
                htmlArr.push('class="active');
            }
            ifLiClass = true;

        }
        if(ifLiClass){
            htmlArr.push('"');
        }
        htmlArr.push('>');

        htmlArr.push(aTagArr.join(''));
        if(node.hasChildren == true){
            htmlArr.push(ulTagArr.join(''));
        }

        htmlArr.push('</li>');

        return htmlArr.join('');
    }


    /**
     * 获取菜单模板html字符串
     * author:wangchen 2017/7/17
     * @returns {*}
     */
    getMenuContentTpl(data) {
        let d = this.formatMenueData(data);
        let htmlArr = [];
        htmlArr.push('<li class="header">HEADER</li>');
        let mm = d['mm'];
        if(mm&&mm.length>0){
            let defaultActive = false;
            for (var i = 0; i < mm.length; i++) {
                if(i==0){
                    defaultActive = true;
                }
                htmlArr.push(this.generateTreeNode(mm[i],defaultActive));
            }
        }

        return htmlArr.join('');
    }

    /**
     * 获取菜单模板
     ***modify by:wangchen 2017/7/17 **************************************************
     ***修改内容：由html模板方式改为js直接拼接html字符串                              *
     ***修改原因：当前使用arttemplate的方式无法在html模板中调用include命令使用嵌套模板*
     ***修改效果：后台数据获取方式不变，可以支持多级菜单展示                          *
     **********************************************************************************
     * @returns {*}
     */
    getMenuTpl() {
        // return require("./menu.html");
        return this.getMenuContentTpl.bind(this);
    }

    /**
     * 渲染菜单
     * @param htmlStr dom元素字符串
     */
    renderMenu(htmlStr) {
        this.menuContainer.html(htmlStr);
        this.fireEvent('initMenued', this);
    }


    /**
     * 设置默认请求地址
     */
    initDefaultUrl() {
        if (store.get("originalUrl")) {
            let originalUrl = store.get("originalUrl");
            window.location.href = originalUrl.indexOf("http://") >= 0 ? originalUrl : "#" + store.get("originalUrl");
            store.remove("originalUrl");
        } else {
            //加载设置默认菜单
            if (window.location.href.indexOf('#') < 0) {
                let ass = this.menuContainer.find('a[href^="#/"]:first');
                if (ass.length > 0) {
                    window.location.href = ass.attr('href');
                }
            }
        }
    }

    /**
     * 根据URL激活当前菜单
     */
    activateMenu() {
        this.menuContainer.find('.active').removeClass('active');
        let url = resolveHandlerPath();
        let menu = this.menus[url] || (function () {
                this.menus[url] = this.menuContainer.find('a[href^="#' + url + '"]');
                return this.menus[url];
            }.bind(this))();
        menu.parent('li').addClass('active').parents('li.treeview').addClass('active');
    }

    get menuUrl() {
        return this._menuUrl;
    }

    set menuUrl(value) {
        this._menuUrl = value;
    }

    get menuId() {
        return this._menuId;
    }

    set menuId(value) {
        this._menuId = value;
    }
};